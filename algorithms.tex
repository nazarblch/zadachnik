\section{Вероятностные методы в Computer Science}

\subsection{Рандомизированные алгоритмы}

\begin{problem}

Требуется определить начиная с какого этажа брошенный с балкона 100-этажного здания стеклянный шар разбивается. В наличии имеется два таких шара. Предложить метод нахождения граничного этажа, минимизирующий математическое ожидание числа бросков. Рассмотреть случай большего числа шаров.  

\end{problem}


\begin{problem}
Имеется неизвестное число от 1 до $n$ ($n\ge 2$). Разрешается задавать любые вопросы с ответами ДА/НЕТ. При этом при ответе ДА мы платим 1 рубль, при ответе НЕТ -- 2 рубля. Сколько необходимо и достаточно заплатить для отгадывания числа?
\end{problem}

\begin{problem}
При нахождении скрытых величин генератора методом максимизации правдоподобия решается следующая оптимизационная задача.

\[
\underset{C}{\max} \; P(C \vert X) \varpropto P(X \vert C),
\]

\noindent где $X$ - множество известных сгенерированных случайных величин, $C$ - множество скрытых  сгенерированных величин.

Генератор представляет собой набор отношений (связей) между величинами из множеств $X$ и $C$. 
Каждая связь является распределением, участвующем в процессе генерации. 

Для решения указанной оптимизационной задачи предлагается подобрать распределение $q(C \vert \lambda)$ схожее с $P(C \vert X)$ по типам зависимостей. Далее, минимизируя расстояние Кульбака-Лейблера $\sum q\left(x\right)\log \frac{q\left(x\right)}{P\left(x\right)}  $ между распределениями $P$ и $q$, найти значения вектора параметров $\lambda$. Вычислив $\lambda$, можно найти сами скрытые переменные $C$ ввиду простой структуры распределения $q(C \vert \lambda)$, которое обычно задается в виде:

\[
q(C \vert \lambda) = \prod q_i(C_i \vert \lambda_i) 
\]        

Рассмотрим пример конкретный пример генератора.

\[
\theta_d \sim Dirichlet(\alpha) \; d = \overline{1,m}
\]
\[
\phi_t \sim Dirichlet(\beta) \; t = \overline{1,K}
\]
\[
z_{di} \sim Categorical(\theta_d) \; i = \overline{1,n_d}
\]
\[
w_{di} \sim Categorical(\phi_{z_{di}}) \; i = \overline{1,n_d},
\]
 
где $W = X$, $C = (\theta, \phi, Z)$, 

$\alpha, \beta, m, n_d, K$ - известные параметры генератора.  

Пусть 
\[
q(\theta \phi, Z \vert \lambda) = \underset{d}{\prod}\underset{t}{\prod}\underset{i}{\prod} Dir(\theta_d | \lambda_{d}) Dir(\phi_t | \eta_{t}) Cat(z_{di} | \lambda_{di})
\]

Требуется найти конечный вид системы уравнений 

\[
\frac{\partial \sum q\left(x\right)\log \frac{q\left(x\right)}{P\left(x\right)} } {\partial \lambda} = 0
\]  

для данного генератора.

\end{problem}

\begin{problem}
Пять философов сидят за круглым столом. В центре стола находится чаша со
спагетти. Между каждой парой соседних философов лежит вилка. Философы чередуют размышления с приемами пищи. Каждый философ может либо есть, либо размышлять. Приём пищи не ограничен
количеством оставшихся спагетти — подразумевается бесконечный запас. Однако
для того, чтобы вытащить спагетти из чаши и донести их до рта философу требуются
две вилки. Таким образом, философ может есть только взяв вилки слева и справа от
себя. 

Каждый философ может взять вилку рядом с ним (если она доступна), или положить
- если он уже держит её. Взятие каждой вилки и возвращение её на стол являются
раздельными действиями, которые должны выполняться одно за другим. Если
требуемая вилка занята соседом, голодный философ вынужден ждать - он не
может вернуться к размышлениям, не поев. После окончания еды философ кладет
обе вилки на стол для того, чтобы ими могли воспользоваться другие философы.

Время одного приема пищи одним философом равномерно распределено на отрезке [0, a]. 
Время одного размышления равномерно распределено на отрезке [0, b].

Данный процесс подвержен взаимной блокировке (Dead Lock): например, если каждый возьмет по левой вилке, то начнется вечное голодание. Для избежания блокировки каждый философ ложит первую вилку, если за время t после ее взятия вторая не освободилась.

Требуется определить распределение времени t, минимизирующее среднее время ожидания после размышления и перед приемом пищи.

\end{problem}


\begin{problem}
\noindent Алгоритм быстрой сортировки основан на парадигме «разделяй и властвуй». Выбирается из элементов массива опорный элемент, относительно которого переупорядочиваются все остальные элементы. Желательно выбрать опорный элемент близким к значению медианы, чтобы он разбивал список на две примерно равные части. Переупорядочивание элементов относительно опорного, происходит так, что все переставленные элементы, лежащие левее опорного, меньше его, а те, что правее -- больше или равны опорному. Далее процедура быстрой сортировки рекурсивно применяется к левому и правому списку для их упорядочивания по отдельности.

Наихудшие входные данные для описанного алгоритма быстрой сортировки (предполагается, что в качестве опорного элемента выбирается последний элемент обрабатываемого массива) -- элементы уже упорядоченные по возрастанию. 
Откуда следует, что асимптотика времени работы быстрой сортировки в худшем случае $\Theta (n^{2} )$.

Оценить время работы алгоритма быстрой сортировки в среднем. 

\begin{ordre}
Получить рекуррентное соотношение для математического ожидания времени работы, введя индикаторную функцию позиции опорного элемента. 
Воспользоваться соотношением:
\[\begin{array}{l} {\sum _{k=1}^{n-1}k\log k \le \log \frac{n}{2} \sum _{k=1}^{\left\lceil \frac{n}{2} \right\rceil -1}k +\log n\sum _{k=\left\lceil \frac{n}{2} \right\rceil }^{n-1}k =} \\ {=\frac{n(n-1)}{2} \log n-\frac{\left\lceil \frac{n}{2} \right\rceil \left(\left\lceil \frac{n}{2} \right\rceil -1\right)}{2} \le \frac{1}{2} n^{2} \log n-\frac{n^{2} }{8} } \end{array}\] 
 
\end{ordre}

Показать неулучшаемость оценки для произвольного алгоритма сортировки. Привести способ сортировки с асимптотикой $O(n \log n)$ в худшем случае.

\end{problem}

\begin{problem}

(Задача поиска k-ой порядковой статистики).
Рекурсивное применение процедуры, основанной на методе быстрой сортировки, позволяет быстро (в среднем) находить k-ую порядковую статистику. Задача вычисления порядковых статистик состоит в следующем: дан список (массив) из $n$ чисел, необходимо найти значение, которое стоит в k-ой позиции в отсортированном в возрастающем порядке списке. 

\noindent Модифицируем алгоритм быстрой сортировки:


 Выбираем опорный элемент. Делим список на две группы. В первой -- элементы меньше опорного, во второй -- больше либо равны.
 Если размер (число элементов) первой группы больше либо равен k, то к ней снова применяется эта процедура. Иначе -- вызывается процедура для второй группы.
 
\noindent Покажите, используя ту же технику, что и при анализе в среднем алгоритма быстрой сортировки, что среднее время работы такого алгоритма линейно.

\begin{ordre}

\noindent Покажите, что выполняется оценка среднего времени работы алгоритма:

\[
E[T(n)]\le E\left\{\sum _{k=1}^{n}X_{k} \left[T\left(\max (k-1,n-k)\right)+O(n)\right] \right\} 
\]
\[ \le \frac{2}{n} \sum _{k=\left\lfloor \frac{n}{2} \right\rfloor }^{n-1}E[T(k)] +O(n)
\]



\end{ordre}

\begin{remark}

Пусть $a\ge 1$ и $b>1$- константы, $f(n)$ - произвольная функция, $T(n)$ - функция, определенная на множестве неотрицательных целых чисел с помощью рекуррентного соотношения: $T(n)=aT\left(\frac{n}{b} \right)+f(n)$

\noindent где выражение $\frac{n}{b} $интерпретируется либо как $\left\lfloor \frac{n}{b} \right\rfloor $, либо как$\left\lceil \frac{n}{b} \right\rceil $. Тогда асимптотическое поведение функции $T(n)$ можно выразить следующим образом. 

\begin{enumerate}
\item  Если $f(n)=O(n^{\log _{b} a-\varepsilon } )$ для некоторой константы $\varepsilon >0$, то $T(n)=\Theta \left(n^{\log _{b} a} \right)$.

\item  Если $f(n)=\Theta \left(n^{\log _{b} a} \right)$, то $T(n)=\Theta \left(n^{\log _{a} b} \lg n\right)$.

\item  Если $f(n)=\Omega (n^{\log _{b} a+\varepsilon } )$ для некоторой константы $\varepsilon >0$, и для некоторой константы $c<1$ и достаточно больших n выполнено: $af\left(\frac{n}{b} \right)\le cf(n)$, то $T(n)=\Theta \left(f(n)\right)$.
\end{enumerate}

\end{remark}
\end{problem}



\begin{problem}

Даны три матрицы $A,B,C$размера $n\times n$. Требуется проверить равенство $AB=C$.

Простой детерминированный алгоритм перемножает матрицы $A$, $B$ и сравнивает результат с $C$. Время работы такого алгоритма при использовании обычного перемножения матриц составляет $O(n^{3} )$, при использовании быстрого - $O(n^{2,376} )$. Вероятностный алгоритм Фрейвалда с односторонней ошибкой проверяет равенство за время $O(n^{2} )$.

Описание вероятностного алгоритма:

\begin{enumerate}
\item \textbf{ }взять случайный вектор $x\in \left\{0,1\right\}^{n} $

\item  вычислить $y=Bx$

\item  вычислить $z=Ay$

\item  вычислить $t=Cx$

\item  если $z=t$ вернуть «да», иначе «нет».
\end{enumerate}

Покажите, что для предъявленного алгоритма выполняется 
\[\begin{array}{l} {P\left\{z=t \vert AB=C\right\}=1,} \\ {P\left\{z \neq t \vert AB\ne C\right\}\ge {\raise0.7ex\hbox{$ 1 $}\!\mathord{\left/ {\vphantom {1 2}} \right. \kern-\nulldelimiterspace}\!\lower0.7ex\hbox{$ 2 $}} .} \end{array}\] 

\begin{ordre}
Оценить вероятность ошибочного ответа на одной ненулевой строке матрицы $D = AB - C$. 
\end{ordre}

\end{problem}

\begin{problem}

Требуется сравнить две битовые строки $a,b$, потребовав как можно меньше информации от обеих строк. Основная идея -- сравнивать не сами строки, а функции от них. Так сравниваются $a\; mod\; p$ и $b\; mod\; p$, для некоторого простого числа $p$. Для этого требуется передать $2\log _{2} p$ бит информации.

Описание алгоритма сравнения строк:

\begin{enumerate}
\item  Пусть $\left|a\right|=\left|b\right|=n$, $N=n^{2} \log _{2} n^{2} $

\item  Выбираем случайное простое число $p$из интервала $\left[2..N\right]$ 

\item  Выдать «да», если $a\; mod\; p=b\; mod\; p\Leftrightarrow (a-b)\equiv 0\; mod\; p$, иначе выдать «нет».
\end{enumerate}

\noindent  Обоснуйте выбор именно простого числа на шаге 2 и предложите способ его генерации.  

\noindent Покажите что,

\[\begin{array}{l} {P\left\{(a-b)\equiv 0,mod(p)|a=b\right\}=1,} \\ {P\left\{(a-b)\equiv 0,mod(p)|a\ne b\right\}=O\left({\raise0.7ex\hbox{$ 1 $}\!\mathord{\left/ {\vphantom {1 n}} \right. \kern-\nulldelimiterspace}\!\lower0.7ex\hbox{$ n $}} \right),} \end{array}\] 
 
При этом необходимое количество переданных бит равно $O\left(\log _{2} n\right)$.

\begin{ordre}

Воспользоваться асимптотическим законом распределения простых чисел:
\[\mathop{\lim }\limits_{n\to \infty } \frac{\pi \left(n\right)}{{\raise0.7ex\hbox{$ n $}\!\mathord{\left/ {\vphantom {n \ln n}} \right. \kern-\nulldelimiterspace}\!\lower0.7ex\hbox{$ \ln n $}} } =1,\] 
где $\pi \left(n\right)$ - функция распределения простых чисел, равная количеству простых чисел, не превосходящих $n$.

\end{ordre}

\end{problem}

\begin{remark}
В предыдущей задаче потребуется проверка простоты числа. 
Согласно малой теореме Ферма, если $N$ - простое число и целое $a$ не делится на $N$, то  
\[a^{N-1} \equiv 1\; mod\; N                         \; \; \;            \left(*\right)\] 

Отсюда следует, что если при каком-то $a$ сравнение $\left(*\right)$ нарушается, то можно утверждать, что $N$ - составное. 
К сожалению,  простой вариант подбора $a$ не всегда позволяет эффективно выявить составное число. Имеются составные числа $N$, обладающие свойством $\left(*\right)$ для любого целого $a$ с условием $\left(a,N\right)=1$ ($a$ и $N$ - взаимно простые). Такие числа называются числами Кармайкла.

В 1976г. Миллер предложил заменить проверку $\left(*\right)$ проверкой несколько иного условия. Если $N$ - простое число, то $N-1=2^{s} t$, где $t$ нечетно, то согласно малой теоремы Ферма для каждого a с условием $\left(a,N\right)=1$ хотя бы одна из скобок в произведении 
\[\left(a^{t} -1\right)\left(a^{t} +1\right)\left(a^{2t} +1\right)\times \ldots \times \left(a^{2^{s-1} t} +1\right)=a^{N-1} -1\] 
делится на $N$. 

Пусть $N$ - нечетное составное число, $N-1=2^{s} t$, где \textbf{$t$ }нечетно. Назовем целое число $a$, $1<a<N$ «выявляющим» для $N$, если нарушается одно из двух условий:

I) $N$ не делится на $a$

II) $a^{t} \equiv 1\; mod\; N$ или существует целое $k$, $0\le k<s$ такое, что 

$a^{2^{k} t} \equiv -1\; mod\; N$.

Если $N$ составное число, то согласно теореме Рабина  существует не менее $\frac{3}{4} \left(N-1\right)$  выявляющих чисел.

\end{remark}

\begin{problem}

Пусть $f(x_{1} ,...,x_{n} )=C_{1} \vee \cdots \vee C_{m} $ - булева формула в дизъюнктивной нормальной форме (ДНФ), где каждая скобка $C_{i} $ - есть конъюнкция $L_{1} \wedge \cdots \wedge L_{k_{i} } $ $k_{i} $ литералов (литерал есть либо переменная, либо ее отрицание). Набор значений переменных $a=(a_{1} ,...,a_{n} )$ называется выполняющим для $f$, если $f(a_{1} ,...,a_{n} )=1$. Требуется найти число выполняющих наборов для данной ДНФ.

\noindent $V$ - множество всех двоичных наборов длины $n$.

\noindent $G$ - множество выполняющих наборов.


\noindent  Проведем $N$ независимых испытаний:

\noindent Выбираем случайно $v_{i} \in V$ ( в соответствии с равномерным распределением).
\noindent $y_{i} =f(v_{i} )$. Заметим, что $P\left\{y_{i} =1\right\}=\frac{\left|G\right|}{\left|V\right|} =p$.
Рассмотрим сумму независимых случайных величин $Y=\sum _{i=1}^{N}y_{i}  $. В качестве аппроксимации $\left|G\right|$ возьмем величину $\frac{Y}{N} \left|V\right|$.

\noindent Оцените необходимое число испытаний $N$ как функцию от $|V|$, $|G|$ и точности аппроксимации $\varepsilon$. 

\begin{ordre}
Докажите следующее утверждение. Пусть $X_{1} ,...,X_{n} $ - независимые случайные величины, принимающие значения 0 или 1, при этом $P\left\{X_{i} =1\right\}=p,\quad P\left\{X_{i} =0\right\}=1-p$. Тогда для $X=\sum _{i=1}^{N}X_{i}  $ и для любого $0<\delta <1$, выполнены неравенства
\[\begin{array}{l} {P\left\{X>(1+\delta )EX\right\}\le e^{-\frac{\delta ^{2} }{3} EX} } \\ {P\left\{X<(1-\delta )EX\right\}\le e^{-\frac{\delta ^{2} }{2} EX} } \end{array}\] 
\end{ordre}

\end{problem}


\begin{problem}

(Задача о покрытии). Дано конечное множество из m элементов и система его подмножеств $S_{1} ,...,S_{n} $. Требуется найти минимальную по числу подмножеств подсистему $S_{1} ,...,S_{n} $, покрывающую все множество объектов. 

\noindent Сформулируем ее в терминах булевых матриц и целочисленного линейного программирования:
\[\left\{\begin{array}{l} {cx\to \min ,} \\ {Ax\ge b,} \\ {\forall j\; x_{j} \in \{ 0,1\} .} \end{array}\right. \] 
Здесь переменные $x_{1} ,...,x_{n} $ соответствуют включению подмножеств $S_{1} ,...,S_{n} $ в решение-покрытие, матрица $A$ - матрица инцидентности, $c=(1...1)^{T} \in {\mathbb R}^{n} ,\quad b=(1...1)^{T} \in {\mathbb R}^{m} $ - векторы стоимости и ограничений.

\noindent Пусть элементы матрицы инцидентности -- независимые случайные величины с бернулевским распределением:$P\{ a_{ij} =1\} =p,$ $P\{ a_{ij} =0\} =1-p$. 

\noindent Для решения задачи применяется жадный алгоритм: на каждом шаге выбирается подмножество, максимально покрывающее еще не покрытые объекты. 

Доказать следующее утверждение. Пусть для случайной матрицы $A$, определенной выше, выполнены соотношения:
\[\begin{array}{l} {\forall \gamma >0:} \\ {\frac{\ln n}{m^{\gamma } } \mathop{\to }\limits_{n\to \infty } 0,} \\ {\frac{\ln m}{n} \mathop{\to }\limits_{n\to \infty } 0.} \end{array}\] 
Тогда для $\forall \varepsilon >0:$ $P\left\{\frac{Z}{M} \le 1+\varepsilon \right\}\mathop{\to }\limits_{n\to \infty } 1$, где Z -- решение жадного алгоритма, M -- величина минимального покрытия. 

\begin{fixme}
Добавить указание.
\end{fixme}

\end{problem}




\subsection{Кодирование}
\subsection{Теория игр}
\begin{problem}
Один игрок прячет (зажимает в кулаке) одну или две монеты достоинством 10 рублей. Другой игрок должен отгадать сколько денег у первого спрятано. Если отгадывает, то получает деньги, если нет -- платит 15 рублей. Каковы ``должны'' быть стратегии игроков при многократном повторении игры?

\end{problem}